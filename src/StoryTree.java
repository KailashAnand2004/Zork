/**
 * The StoryTree class.
 *
 * @author
 *   Kailash Anand ID:115158238
 * Assignment:
 *    Recitation: R01
 *    Homework #5 for CSE 214
 * Date:
 *    April 10th, 2023
 */
import java.util.*;
import java.io.*;
import java.util.zip.DataFormatException;

public class StoryTree
{
    private final StoryTreeNode root;//A reference to the root StoryTreeNode of this tree.
    private StoryTreeNode cursor;//A reference to the currently selected StoryTreeNode in the tree.

    //The current state of the game, which indicates whether the game has ended and, if so, what the result of the game is.
    private GameState gameState = GameState.GAME_NOT_OVER;
    static Scanner input;//An instance of scanner class to take input.
    private String prev = "";

    private String answer = "";

    /**
     * Default constructor for the StoryTree class.
     */
    public StoryTree()
    {
        root = new StoryTreeNode();
        root.setPosition("root");
        root.setOption("root");
        root.setMessage("Hello, and Welcome to Zork!");
        cursor = root;
    }

    /**
     * Used to play the game.
     *
     * @param choice
     *  The integer input by the user which represents the choice in the game.
     */
    public void play(int choice)
    {
            if (choice <= getOptions().length)
            {
                switch (choice)
                {
                    case 1:
                        cursor = cursor.getLeftChild();
                        break;

                    case 2:
                        cursor = cursor.getMiddleChild();
                        break;

                    case 3:
                        cursor = cursor.getRightChild();
                        break;
                }
            }

            if (cursor.isWinningNode())
            {
                gameState = GameState.GAME_OVER_WIN;
                System.out.println(cursor.getMessage());
                System.out.println("\nThanks for playing.");
            }
            else if (cursor.isLosingNode())
            {
                gameState = GameState.GAME_OVER_LOSE;
                System.out.println(cursor.getMessage());
                System.out.println("\nThanks for playing.");
            }
    }

    /**
     * Reads in a text file describing a StoryTree.
     *
     * @param fileName
     *  Name of the file to read from.
     *
     * @Preconditions
     *  filename is a non-null, non-empty String that points to a file that exists that is readable, and is valid.
     *
     * @return
     *  A new StoryTree generated by the passed in text file is returned.
     *
     * @throws FileNotFoundException
     *  The file contained data inconsistent with the expected data format
     */
    public static StoryTree readTree(String fileName) throws FileNotFoundException
    {
        try
        {
            File file = new File(fileName);
            input = new Scanner(file);
        }
        catch(FileNotFoundException f)
        { return new StoryTree(); }
        StoryTree newTree = new StoryTree();
        boolean here = false;

        while (input.hasNextLine())
        {
            String Input = input.nextLine();
            String[] story = Input.split(" [\\|] ");


            for (int i = 0; i < story.length; i++)
            {
                if (story[i].substring(0, 1).matches("[0-9]"))
                {
                    newTree.cursor = newTree.root;
                    String[] direction = story[i].split("-");
                    StoryTreeNode newNode = new StoryTreeNode();

                    for (int j = 0; j < direction.length; j++)
                    {
                        switch (direction[j])
                        {
                            case ("1"):
                                if (newTree.cursor.getLeftChild() == null)
                                {
                                    newTree.cursor.setLeftChild(newNode);
                                    newTree.cursor = newNode;
                                }
                                else
                                {
                                    newTree.cursor = newTree.cursor.getLeftChild();
                                }
                                break;

                            case ("2"):
                                if (newTree.cursor.getMiddleChild() == null)
                                {
                                    newTree.cursor.setMiddleChild(newNode);
                                    newTree.cursor = newNode;
                                }
                                else
                                {
                                    newTree.cursor = newTree.cursor.getMiddleChild();
                                }
                                break;

                            case ("3"):
                                if (newTree.cursor.getRightChild() == null)
                                {
                                    newTree.cursor.setRightChild(newNode);
                                    newTree.cursor = newNode;
                                }
                                else
                                {
                                    newTree.cursor = newTree.cursor.getRightChild();
                                }
                                break;
                        }
                    }
                    newTree.cursor.setPosition(story[i]);
                    here = true;
                }
                else
                {
                    if (here)
                    {
                        newTree.cursor.setOption(story[i]);
                    } else
                    {
                        newTree.cursor.setMessage(story[i]);
                    }
                    here = false;
                }
            }
        }

        newTree.cursor = newTree.root;
        input = new Scanner(System.in);
        newTree.cursor = newTree.cursor.getLeftChild();
        return newTree;
    }

    /**
     * Saves a StoryTree to the indicated file using the specified data format.
     *
     * @param fileName
     *  Name of the file to read from.
     *
     * @param tree
     *  A reference to the tree to save to the indicated file.
     *
     * @throws IOException
     */
    public static void saveTree(String fileName, StoryTree tree) throws IOException
    {
        BufferedWriter out = new BufferedWriter(new FileWriter(fileName));

        tree.cursor = tree.root.getLeftChild();
        out.write(tree.preorder(tree.cursor));
        out.close();
    }

    /**
     *  Getter method for the gameState
     *
     * @return
     *  Returns the gameState.
     */
    public GameState getGameState()
    {
        return gameState;
    }

    /**
     * Getter method for position
     *
     * @return
     *  The position of the cursor.
     */
    public String getCursorPosition()
    {
        return cursor.getPosition();
    }

    /**
     * Getter method for message
     *
     * @return
     *  The message of the cursor.
     */
    public String getCursorMessage() {
        return cursor.getMessage();
    }

    /**
     * Returns an array of String pairs for each immediate child of the cursor.
     */
    public String[][] getOptions() {
        if (!cursor.isLeaf())
        {
            String[][] options = new String[3][2];

            for (int i = 0; i < options.length; i++)
            {
                for (int j = 0; j < options[0].length; j++)
                {
                    switch (i)
                    {
                        case 0:

                            if (cursor.getLeftChild() != null)
                            {
                                if (j == 0) {
                                    options[i][j] = "" + (i + 1) + " ";
                                }

                                if (j == 1) {
                                    options[i][j] = cursor.getLeftChild().getOption();
                                }
                            }
                            break;

                        case 1:

                            if (cursor.getMiddleChild() != null) {
                                if (j == 0) {
                                    options[i][j] = "" + (i + 1) + " ";
                                }

                                if (j == 1) {
                                    options[i][j] = cursor.getMiddleChild().getOption();
                                }
                            }
                            break;

                        case 2:

                            if (cursor.getRightChild() != null)
                            {
                                if (j == 0) {
                                    options[i][j] = "" + (i + 1) + " ";
                                }

                                if (j == 1) {
                                    options[i][j] = cursor.getRightChild().getOption();
                                }
                            }
                            break;
                    }
                }
            }
            return options;
        } else {
            String[][] options = new String[1][1];
            options[0][0] = cursor.getMessage();
            return options;
        }
    }

    public void setCursorMessage(String message)
    { cursor.setMessage(message); }

    public String getCursorOption()
    { return cursor.getOption(); }

    public void setCursorOption(String option)
    { cursor.setOption(option); }

    /**
     * Resets the cursor to the root node.
     *
     * @Postconditions
     *  The cursor refrences the root node.
     */
    public void resetCursor() {
        cursor = root.getLeftChild();
        gameState = GameState.GAME_NOT_OVER;
    }

    /**
     * Selects the child with the name indicated by position.
     *
     * @param position
     *  The position String of the child node to select
     *
     * @Preconditions
     *  The child with the indicated position member variable exists as a direct child of the cursor.
     *
     * @Postconditions
     *  Cursor references node indicated by position.
     *
     * @throws NodeNotPresentException
     *  Node with indicated position variable was not found.
     */
    public void selectChild(String position) throws NodeNotPresentException {
        if (position == null) {
            throw new IllegalArgumentException();
        }

        switch (position) {
            case "1":
                if (cursor.getLeftChild() != null) {
                    cursor = cursor.getLeftChild();
                }
                else
                { throw new NodeNotPresentException(); }
                break;

            case "2":
                if (cursor.getMiddleChild() != null) {
                    cursor = cursor.getMiddleChild();
                }
                else
                { throw new NodeNotPresentException(); }
                break;

            case "3":
                if (cursor.getRightChild() != null) {
                    cursor = cursor.getRightChild();
                }
                else
                { throw new NodeNotPresentException(); }
                break;

            default:
                throw new NodeNotPresentException();
        }

    }

    /**
     * Adds a new child under the current cursor, with given option and message.
     *
     * @param option
     *  The new String to set as the option of the new child.
     *
     * @param message
     *  The new String to set as the message of the new child.
     *
     * @Postconditions
     *  Cursor has new child, with specified message and option.
     *
     * @throws TreeFullException
     *  All three child spots are already full.
     */
    public void addChild(String option, String message) throws TreeFullException {
        if (option == null || message == null)
        {
            throw new IllegalArgumentException();
        }

        StoryTreeNode newChild = new StoryTreeNode();
        newChild.setMessage(message);
        newChild.setOption(option);

        if (cursor.getLeftChild() == null)
        {
            newChild.setPosition(getCursorPosition() + "-1");
            cursor.setLeftChild(newChild);
        }
        else if (cursor.getMiddleChild() == null)
        {
            newChild.setPosition(getCursorPosition() + "-2");
            cursor.setMiddleChild(newChild);
        }
        else if (cursor.getRightChild() == null)
        {
            newChild.setPosition(getCursorPosition() + "-3");
            cursor.setRightChild(newChild);
        }
        else
        {
            throw new TreeFullException();
        }
    }

    /**
     * Removes an immediate child under the current cursor.
     *
     * @param position
     *  String indicating the position of the child to be removed.
     *
     * @return
     *  A reference to the child removed.
     *
     * @Preconditions
     *  The child with the indicated position member variable exists as a direct child of the cursor.
     *
     * @Postconditions
     *  The indicated child and it's entire sub-tree have been removed from the tree.
     *
     * @throws NodeNotPresentException
     *  Node with indicated position variable was not found.
     */
    public StoryTreeNode removeChild(String position) throws NodeNotPresentException
    {
        StoryTreeNode returned = new StoryTreeNode();

        if (position.equals("3") && cursor.getRightChild() != null)
        {
            returned = cursor.getRightChild();
            cursor.setRightChild(null);
        }
        else if (position.equals("2") && cursor.getMiddleChild() != null)
        {
            returned = cursor.getMiddleChild();
            if (cursor.getRightChild() != null)
            {
                cursor.setMiddleChild(cursor.getRightChild());
                cursor.setRightChild(null);
            }
            else
            { cursor.setMiddleChild(null); }
        }
        else if (position.equals("1") && cursor.getLeftChild() != null)
        {
            returned = cursor.getLeftChild();
            if (cursor.getMiddleChild() != null)
            {
                cursor.setLeftChild(cursor.getMiddleChild());
                cursor.setMiddleChild(null);
            }
            else
            { cursor.setLeftChild(null); }

            if (cursor.getRightChild() != null)
            {
                cursor.setMiddleChild(cursor.getRightChild());
                cursor.setRightChild(null);
            }
        }
        else
        { throw new NodeNotPresentException(); }

        cursor.fixPosition();
        return returned;
    }

    /**
     * Addition extra credit method that allows the cursor to return to its direct parent.
     */
    public void returnToParent() {
        String position = cursor.getPosition();
        String[] direction = position.split("-");
        resetCursor();

        for (int i = 1; i < direction.length - 1; i++) {
            switch (direction[i]) {
                case "1":
                    cursor = cursor.getLeftChild();
                    break;

                case "2":
                    cursor = cursor.getMiddleChild();
                    break;

                case "3":
                    cursor = cursor.getRightChild();
                    break;
            }
        }
    }

    /**
     * Preorder traversal of the tree.
     *
     * @param node
     *  The node to traverse from.
     *
     * @return
     *  A string to save.
     */
    public String preorder(StoryTreeNode node) {

        answer += node.getPosition() + " | " + node.getOption() + " | " + node.getMessage() + "\n";
        if (node.getLeftChild() != null) {
            preorder(node.getLeftChild());
        }

        if (node.getMiddleChild() != null) {
            preorder(node.getMiddleChild());
        }

        if (node.getRightChild() != null) {
            preorder(node.getRightChild());
        }

        return answer;
    }

    /**
     * Getter method for cursor
     *
     * @return
     *  Returns the cursor.
     */
    public StoryTreeNode getCursor()
    {
        return cursor;
    }
}
